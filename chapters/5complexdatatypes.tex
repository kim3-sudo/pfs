\chapter{Complex Datatypes}
It may seem strange that we aren't covering complex \index{datatype}datatypes right next to simple datatypes, but it's for a reason: knowing how to use simple datatypes and basic Python functionality is key to understanding and utilizing these complex datatypes.\par
Python has four complex datatypes that are available for you to use out-of-the-box: \index{datatype!list}lists, \index{datatype!dictionary}dictionaries, \index{datatype!tuple}tuples, and \index{datatype!set}sets. We will go over all four types, but we will spend most of our focus on lists and dictionaries.\par
It's also possible for us to make our own complex datatypes, and we'll do that when we cover classes in Chapter 7.
\section{Lists}
Let's imagine for a moment: you want to process the statistics for each rider on your favorite pro cycling teams. Sure, you could create variables for name, functional threshold power (FTP), peak power, and watts per kilogram for every rider. What might this look like?\footnote{Readers should note that this data is fabricated. Do not use these figures in your code.}\par
\begin{lstlisting}[style=pippython]
ath1name = "Peter Sagan"
ath1ftp = 470
ath1peak = 1230
ath1wpk = 6.7
ath2name = "Caleb Ewan"
ath2ftp = 471
ath2peak = 1903
ath2wpk = 7.0
\end{lstlisting}
Here we run into an inherent problem with individual variables: it gets really messy, really fast. It'd be really easy to spend all day making individual variables for every single rider. Well, there's a better way: lists. Lists are one of the \newterm[complex datatypes]{complex datatypes} in Python, and they allow us to store multiple pieces of individual data in a single data structure.\par
You can think of a list as a sequence of individual pieces of data. Instead of storing our data as individual variables, we can store all of the names in one list, all of the FTP data in a different list, all of the peak power figures in a third list, and all of the watts per kilogram measurements in a fourth list. Let's look at how to create these lists and get the data out of them.\par
\subsection{Creating Lists}
Creating lists isn't a particularly difficult task, and the same general structure applies as when declaring and initializing a variable. Let's use the same data as above, but expand on it a little bit. For these examples, we'll use five athletes. If we were to write each of these as individual variables, we'd have 20 variables, but instead, we can store all of the data we need in just four variable.\par
Lists are stored in variables, just like individual values. We even use the same assignment operator \verb|=|. The only thing that's different is the form of the data that we're putting into our variable. In Python, we create lists using square brackets \verb|[]| to denote the start and end of the list and commas \verb|,| to delimit each of the elements in the list. Consider the following code.\footnote{Again, all of the data has been fabricated.}\par
\begin{lstlisting}[style=pippython]
names = ["Peter Sagan",
    "Caleb Ewan",
    "Mathieu Van Der Poel",
    "Chris Froome",
    "Mark Cavendish"]
ftps = [470, 471, 460, 480, 465]
peaks = [1230, 1903, 1653, 1403, 1109]
wpks = [6.7, 7.0, 6.7, 6.3, 6.2]
\end{lstlisting}
As you can see, we're adding elements to our lists just as we would assign individual values to a variable. We use the same syntax to indicate a string (double quotes) or float (decimal points).\par
\warningtext{Common pitfall: comma placement}{When writing out a list of strings, it is surprisingly easy to accidentally put your commas inside of your strings instead of outside, as the former is common in English writing. If you do put a comma inside of a string, there is nothing to delimit the two strings, so Python won't be able to store the string and your program will likely crash.}
If your code isn't working, you might want to double-check that you've placed your commas correctly. The following code has just one misplaced comma that will prevent the code from running properly.\par
\begin{lstlisting}[style=pippython]
names = ["Peter Sagan,"
    "Caleb Ewan",
    "Mathieu Van Der Poel",
    "Chris Froome",
    "Mark Cavendish"]
\end{lstlisting}
It's also possible to mix the datatypes that go in your lists. For example, we could also structure our data by creating one variable for each athlete, as shown here.
\begin{lstlisting}[style=pippython]
saganData = ["Peter Sagan", 470, 1230, 6.7]
ewanData = ["Caleb Ewan", 471, 1903, 7.0]
vanDerPoelData = ["Mathieu Van Der Poel", 460, 1653, 6.7]
froomeData = ["Chris Froome", 480, 1403, 6.3]
cavendishData = ["Mark Cavendish", 465, 1109, 6.2]
\end{lstlisting}
When you're writing your own programs, there isn't necessarily a "right" and a "wrong" way to represent your data, but you should consider what kind of problem you're trying to solve and construct your variables around that. There are certainly "worse" and "better" ways to represent data. If you were trying to create a program that calculated average stats for all of the athletes on a team, then the first model might work better. It's a lot easier to grab all of the elements of just one array, rather than having to iterate through each of the variables for each athlete. However, if you were trying to create a program that showed all of the data for a certain athlete, then the second model would be easier to work with. It would be a lot easier than grabbing one bit of data from a bunch of variables.
\subsubsection*{Exercise Questions}
These exercise questions cover chapter 5.1.
\begin{Exercise}
    \Question{In your own words, describe what a list is.}
    \Question{What advantages do lists offer over simpler datatypes?}
    \Question{What drawbacks to lists have compared to their simpler counterparts?}
\end{Exercise}
\begin{Exercise}
    \Question{Provide an example of a list with all of the same datatype from earlier in this chapter.}
    \Question{For the list that you chose, what datatypes are in the list?}
    \Question{Can you put multiple datatypes into one list? If so, provide an example of this from earlier in this chapter. If not, provide the error message that Python generates.}
\end{Exercise}
\begin{Exercise}
    \Question{What characters are used to enclose a list in Python?}
    \Question{What separates each of the elements in a Python list?}
\end{Exercise}
\begin{Exercise}
    \Question{Write a Python list that has the names of five of your professors or instructors and put the list into a variable called \verb|instructors|.}
    \Question{Write a Python list that has five breeds of dogs and put the list into a variable called \verb|dogs|.}
    \Question{Write a Python list that has the names of four cities and put the list into a variable called \verb|cities|.}
    \Question{Write a Python list that has the number of stories of three residence halls on your campus and put the list into a variable called \verb|resHallHeights|. Follow the line with a comment with the name of the residence halls, but do not store the names in the actual list.}
\end{Exercise}
\subsection{Accessing Data Inside of Lists}
Now that we've created our list, it's probable that we'd want to access some data inside of that list.\par
In the past, when we stored individual elements to a variable, we could just call that variable to get its contents, such as shown here.
\begin{lstlisting}[style=pippython]
ath4name = "Chris Froome"
print(ath4name)
\end{lstlisting}
\begin{lstlisting}[style=none]
Chris Froome
\end{lstlisting}
There's nothing special about the code that we just saw. But, what if we tried to print a list?\par
\begin{lstlisting}[style=pippython]
froomeData = ["Chris Froome", 480, 1403, 6.3]
print(froomeData)
\end{lstlisting}
\begin{lstlisting}[style=none]
['Chris Froome', 480, 1403, 6.3]
\end{lstlisting}
Python very helpfully prints everything in the list. It can't read our mind and figure out that we only want the name, or the first element of the vector.\footnote{The term "list" is a term very specific to Python. In other languages, the more commonly used term is "vector." If you see the term "vector," understand it to mean what a Python list is.}\footnote{There is a difference between arrays and vectors, namely that arrays are assigned a specific length in memory when they are declared, while vectors can be expanded and shrunken at will. Since Python does not differentiate between arrays and vectors, we will not cover their differences in depth in this book, but you'll find more detail in a book on a language with memory management, such as C++.} Instead, we need to instruct Python to only give us a certain \newterm[element]{datatype!list!element} in the list. An element is one individual chunk of data in a list.\par
\boxtext{Why the quotes?}{Observe in the above list how Chris Froome is printed surrounded by single quotes. This is because we are mixing our datatypes in a list, and Python wants to make sure that we know that this is a string. If you see quotes surrounding a list element, you should automatically consider it to be a string element. There is no such differentiation, however, between integers and floats.}\par
\boxtext{Typecasting a list versus list element}{Recall how we \indexterm{typecast} variables in chapter 4.6. We can also typecast elements of a list. Simply refer to the variable that the list is in, along with the element index. Remember to not typecast the entire list if you're only trying to typecast an element in a list.}
We can tell Python to give us the $n$th element in a list, where $n$ is the index of the element in the list, starting at 0. You can think of the $n$th element in a list as you would think of an element in a sequence in calculus. The $n$th element of the Fibonacci sequence $F$ could be denoted as $F_{n}$, where $n$ is the element of the sequence. In this case, instead of sequences, we're looking at lists, and instead of numbers, any type of data can be represented. Let's look at our Chris Froome list in a table, along with the \indexterm{index}\footnote{In this book, we refer to the plural of "index" as "indices." However, you may also see "indexes" written in documentation or in other textbooks.} numbers.\par
\vspace{5mm}
\begin{tabular}{|l|l|l|l|l|}
\hline
Index & 0              & 1   & 2    & 3   \\
\hline
Data  & \verb|"Chris Froome"| & \verb|480| & \verb|1403| & \verb|6.3|\\
\hline
\end{tabular}\par
\vspace{5mm}
\warningtext{Indices start at zero}{Remember, in Python, indices start at 0, not at 1!}\par
If we wanted to get the name, then we could ask Python to give us the 0th element of the array. In Python, we do this using square brackets, just not in the same way that we used to initialize the array. Instead, we can write the name of the variable that has the data in it, followed by square brackets with the index number of the element of the array. Don't add an extra space in between the variable name and the square brackets with the index number.\par
\begin{lstlisting}[style=pippython]
froomeData = ["Chris Froome", 480, 1403, 6.3]
print(froomeData[0])
\end{lstlisting}
\begin{lstlisting}[style=none]
Chris Froome
\end{lstlisting}
Since we're printing a specific element of the array, it prints without the square brackets, commas, or any quotation marks around strings.\par
It's very easy for beginning programmers to forget that arrays start at zero in almost every programming language.\footnote{Arrays start at one in Matlab for some ungodly reason, but it is very much the exception.} If you're having issues getting a specific element of a list, you should double-check that your index number is correct.\par
Just like how we've accessed an element in a list, we can also change that item's value. Changing the value of an element of a list is just like changing an individual variable. However, instead of referring to the variable as a whole, you should only refer to the specific index of data that is to be overwritten. For example, say I got Chris Froome's FTP incorrect: it should be changed to 483. I know that the index of the FTP in the \verb|froomeData| list is at location 1, so I can get the old value easily.
\begin{lstlisting}[style=pippython]
print(froomeData[1])
\end{lstlisting}
\begin{lstlisting}[style=none]
480
\end{lstlisting}
We can also edit that value as if we were editing a regular variable.
\begin{lstlisting}[style=pippython]
froomeData[1] = 483
print(froomeData[1])
\end{lstlisting}
\begin{lstlisting}[style=none]
483
\end{lstlisting}
It might also be helpful to know how many elements are in the list. Python can provide this via the \verb|len()| function, which lets us know the length of the list. \verb|len()| takes one argument, the name of a list, and it returns an integer with the number of elements in the list. Let's say that we forgot how many athletes were in the \verb|names| list. We could use the following to print the length of the list.\par
\begin{lstlisting}[style=pippython]
print(len(names))
\end{lstlisting}
\begin{lstlisting}[style=none]
5
\end{lstlisting}
The return value of the \verb|len()| function is just a regular integer.\par
\subsection{Appending to Lists}
Down the line, it's possible that you'd want to append to a list. Appending an element means that you are adding that new element to the end of an existing list. In order to append to a list, your list must already exist.\par
Let's go back to the original example of lists. It is provided below, for your convenience.
\begin{lstlisting}[style=pippython]
names = ["Peter Sagan",
    "Caleb Ewan",
    "Mathieu Van Der Poel",
    "Chris Froome",
    "Mark Cavendish"]
ftps = [470, 471, 460, 480, 465]
peaks = [1230, 1903, 1653, 1403, 1109]
wpks = [6.7, 7.0, 6.7, 6.3, 6.2]
\end{lstlisting}\footnote{For reference, FTP (functional threshold power), peak power, and WPK (watts per kilogram) are real units for measuring cycling performance, even if the actual measurements are made up. They represent the power that a cyclist can put out.}
Using this code, imagine that we wanted to add another athlete, Tadej Poga\v{c}ar. We could reinitialize all of the lists with the new data, but that's an awful lot of work for something so trivial. Thankfully, Python has a much easier way: the \verb|append()| method. \verb|append()| only takes one argument: the element that is to be appended to the end of the existing list. Instead of passing in the list to append to as an argument, we will instead use a \newterm[method]{functions!method} on the list itself. A method is a way of manipulating a data structure, like a list.\par
The syntax to add an element to a list is as follows.\par
\begin{lstlisting}[style=pippython]
names.append("Tadej Pogacar")
ftps.append(466)
peaks.append(1369)
wpks.append(6.5)
\end{lstlisting}
Since we are using a method on a data structure (the structure is a list), we will put the name of the method after the name of the data structure itself, separated by a period. We can then pass any arguments that we need to pass into to the method inside of the parentheses. Do not confuse methods with functions. They are similar, but they aren't exactly the same. We'll get to those differences in chapter 7.3.\par
What if we want to add multiple pieces of data to an existing list? Let's say that we had two lists, one for male and one for female athletes, but we needed to combine these lists into one. We can use the \verb|extend()| method. \verb|extend()| takes one argument, another list.\footnote{You can also pass in a tuple or a set, but these are topics that we won't cover in depth in this book.} Consider the following code, which creates two lists of names, one for males and one for females, then combines them into one list.
\begin{lstlisting}[style=pippython]
maleNames = ["Peter Sagan",
    "Caleb Ewan",
    "Mathieu Van Der Poel",
    "Chris Froome",
    "Mark Cavendish"]
femaleNames = ["Hannah Barnes",
    "Ella Harris",
    "Jessica Pratt",
    "Ellen van Dijk",
    "Katie Hall"]
allNames = maleNames
allNames.extend(femaleNames)
\end{lstlisting}
We begin by creating our two lists as normal. Then, we can put our list of male names into a new list called \verb|allNames|. We can then extend the \verb|allNames| list using the list of female names. After this, \verb|allNames| has all of the athlete names.\par
\warningtext{Append Versus Extend}{If you attempt to use the append method to append a list to another list, you'll end up creating a nested list, not adding the components of the list to the other list. If you attempt to use the extend method to add a single item to a list, you'll end up with an error, since the extend method expects a list as its argument.}
Just as we have appended to a list, we can also remove items from an existing array. We can do this either by name or by index number. Let's say that we wanted to remove Mark Cavendish from the \verb|allNames| list. We know that his index number is 4 (remember, indices start at 0) and that his entry is \verb|"Mark Cavendish"|, and we can use either to remove the element.\par
If we wanted to remove by name, we can use the \verb|remove()| method. We can pass in the exact data that we want to remove as whatever datatype the data is stored as at that list location. That is, if the data is an integer, we can pass an integer into the \verb|remove()| method. However, we know that the entry is a string, so we'll pass in a string literal.
\begin{lstlisting}[style=pippython]
allNames.remove("Mark Cavendish")
\end{lstlisting}
We can also remove by index by using the \verb|pop()| method. The \verb|pop()| method can only take an integer, the index number of the element.
\begin{lstlisting}[style=pippython]
allNames.pop(4)
\end{lstlisting}
If you do not specify an argument for \verb|pop()|, Python will remove the last element of the array.\par
Finally, we can clear all of the elements of a list. Clearing the elements only clears the contents; it does not remove the list itself. The list only has no content. We do this using the \verb|clear()| method. \verb|clear()| takes no arguments.
\begin{lstlisting}[style=pippython]
maleNames.clear()
\end{lstlisting}
\subsubsection*{Exercise Questions}
\begin{Exercise}
    \Question{Where do indices start in Python lists?}
    \Question{Lists contain multiple objects. What is the formal name for these individual objects?}
    \Question{If you wanted to access the $n$th element of a list, what index number would you give Python in terms of $n$?}
\end{Exercise}
\begin{Exercise}
Consider the \verb|instructors| list that you made in chapter 5.1.1.
    \Question{How long is the list? Give the Python code that gave you how long the list is.}
    \Question{What is the third element of that list? Give the Python code that gave you the third element. Remember, indices start at 0 in Python, so make sure you're getting the third element, not the fourth element!}
    \Question{Add two new professors or instructors to the \verb|instructors| list. What code did you use? Also give the new length of the list, along with the code that you used to get the length of the list.}
    \Question{Print the \verb|instructors| list. Then, remove the third professor or instructor from the \verb|instructors| list by the value of the element (rather than the index). What code did you use?}
    \Question{Without printing the list again, remove the element with index number 4 (not the fourth) from the \verb|instructors| list using the index number (rather than the element value). What code did you use?}
\end{Exercise}
\begin{Exercise}
Consider the \verb|cities| list that you made in chapter 5.1.1.
    \Question{Change the third element (careful about the what the index number is!) to "Berlin" (it's okay if you already have Berlin in your list, we'll just add it again). Provide your code.}
    \Question{Run the following in the Python interpreter: \verb|cities[2]|. What is the output?}
    \Question{Clear all of the elements from the \verb|cities| list, then print the list. What is the code that you used to clear the elements from the list? What is the output?}
    \Question{Now, what datatype is \verb|cities|: list, list of strings, or \indexterm{Nonetype}?}
\end{Exercise}

\section{Dictionaries}
Lists are just one way of storing multiple pieces of data. There are also dictionaries, and they operate in a fundamentally different ways compared to lists.\par
\subsection{Lists Versus Dictionaries}
While lists and dictionaries might appear similar on the surface, each has their own positives and negatives. The underlying concept of each data structure is different, for one. When we took a look at lists and how to get certain elements from lists, we saw that we could draw a table with our index and the data at that index location. Comparatively speaking, dictionaries use a key instead of an index. While lists store data as a sequence of data, lists are stored in key-data pairs. The keys in dictionaries are like sub-variable names, and they describe a specific piece of data within the larger dictionary.\par
Another way to think of dictionaries in Python is to compare them to real dictionaries with words and definitions. In a word dictionary, the words are sorted in some logical manner (alphabetically) and the accompanying data (the definition) is stored alongside the words. In Python, the words are the keys and the definitions are the data.\par
\subsection{Creating Dictionaries}
Just like creating a list is like declaring a variable, creating a dictionary is like creating a list.\par
Let's take a look at how we could represent the data in the second model of lists in chapter 5.1. The data is provided here again.
\begin{lstlisting}[style=pippython]
saganData = ["Peter Sagan", 470, 1230, 6.7]
ewanData = ["Caleb Ewan", 471, 1903, 7.0]
vanDerPoelData = ["Mathieu Van Der Poel", 460, 1653, 6.7]
froomeData = ["Chris Froome", 480, 1403, 6.3]
cavendishData = ["Mark Cavendish", 465, 1109, 6.2]
\end{lstlisting}
At first glance, the name makes sense, but what are the numbers next to the names? We might be able to remember, but it'd be a lot easier if everything was labeled. This is the perfect opportunity to use a dictionary. We could represent the above data as shown in this code.
\begin{lstlisting}[style=pippython]
saganData = {
    "name": "Peter Sagan",
    "ftp": 470,
    "peak": 1230,
    "wpk": 6.7
}
ewanData = {
    "name": "Caleb Ewan",
    "ftp": 471,
    "peak": 1903,
    "wpk": 7.0
}
vanDerPoelData = {
    "name": "Mathieu Van Der Poel",
    "ftp": 460,
    "peak": 1653,
    "wpk": 6.7
}
froomeData = {
    "name": "Chris Froome",
    "ftp": 480,
    "peak": 1403,
    "wpk": 6.3
}
cavendishData = {
    "name": "Mark Cavendish",
    "ftp": 465,
    "peak": 1109,
    "wpk": 6.2
}
\end{lstlisting}
To create a dictionary (or five), surround the contents of each dictionary with curly braces \verb|{}|. Specify the key first, in quotes, as it is a string literal. Delimit the key and the data using a colon \verb|:|, then enter the data that should occupy that key. Separate individual lines with commas \verb|,|. It seems complicated, but with enough time, it's actually pretty simple.\par
As you can see, you can use the same key names in multiple different variables. However, you cannot use the same key name within one dictionary. For example, the following code is not syntactically correct, even though the values are different.
\begin{lstlisting}[style=pippython]
saganData = {
    "name": "Peter Sagan",
    "ftp": 470,
    "peak": 1230,
    "wpk": 6.7
    "wpk": 6.9
}
\end{lstlisting}
\begin{lstlisting}[style=none]
SyntaxError: invalid syntax
\end{lstlisting}
However, we could use the following dictionary, which is syntactically correct.
\begin{lstlisting}[style=pippython]
saganData = {
    "name": "Peter Sagan",
    "ftp": 470,
    "peak": 1230,
    "wpk1": 6.7
    "wpk2": 6.9
}
\end{lstlisting}
\subsection{Accessing Data Inside of Dictionaries}
Accessing data inside of dictionaries is remarkably similar to how we access data inside of lists. We even use the same characters!\par
When accessing data inside of a dictionary, we still use the square brackets \verb|[]| that we used to access data from lists, but what goes inside of those brackets is different. In lists, we put the index number of the element of the array. However, we don't have an index number in a dictionary. Instead, we can use the element's key to get its value. Since we're using a string literal, we need to put the key's name inside of quotes. Consider the following code.\par
\begin{lstlisting}[style=pippython]
froomeData = {
    "name": "Chris Froome",
    "ftp": 480,
    "peak": 1403,
    "wpk": 6.3
}
print(froomeData["ftp"])
\end{lstlisting}
\begin{lstlisting}[style=none]
480
\end{lstlisting}
If you've forgotten what you named your keys, you can also pull up a list of keys for any given dictionary by using the \verb|keys()| method, as shown below.
\begin{lstlisting}[style=pippython]
print(froomeData.keys())
\end{lstlisting}
\begin{lstlisting}[style=none]
dict_keys(['name', 'ftp', 'peak', 'wpk'])
\end{lstlisting}
Python will return the name of all of the keys as a list.\par
\subsection{Appending to Dictionaries}
Appending to dictionaries is an inevitable part of programming as you become more familiar with the tools of the language. You'll never be able to store all the data in your variable initialization, so we'll need to know how to append.\par
Unlike lists, we don't have a simple method to append a new key to a dictionary, like \verb|append()|. Instead, we can append items by simply defining a new key and data pair for the dictionary. Let's say that we wanted to add an updated FTP value for Chris Froome in a key called \verb|updatedFTP|.
\begin{lstlisting}[style=pippython]
froomeData = {
    "name": "Chris Froome",
    "ftp": 480,
    "peak": 1403,
    "wpk": 6.3
}
froomeData["updatedFTP"] = 485
print(froomeData.keys())
\end{lstlisting}
\begin{lstlisting}[style=none]
dict_keys(['name', 'ftp', 'peak', 'wpk', 'updatedFTP'])
\end{lstlisting}
As we can see, there is a new key named \verb|updatedFTP|. We can then use this key as we would any other.\par
However, dictionaries are not method-less. In order to modify existing data, we can use the \verb|update()| method. \verb|update()| takes one argument, a dictionary with new data. Let's say that we wanted to change Chris Froome's FTP, since it was wrong; instead of 480, it should be 483. We can use \verb|update()| to pass in a dictionary specifying the key that should be changed and the value that it should be changed to.\par
\begin{lstlisting}[style=pippython]
froomeData = {
    "name": "Chris Froome",
    "ftp": 480,
    "peak": 1403,
    "wpk": 6.3
}
froomeData.update({"ftp": 483})
\end{lstlisting}
The brackets and braces might look confusing, but break it down and it becomes quite simple. The outer parentheses \verb|()| are for the \verb|update()| method, and they specify arguments for that method. The curly braces \verb|{}| are for the dictionary, and they specify that the data being passed in is a dictionary and what the contents of that dictionary are.\par
Of note is that if you attempt to run the \verb|update()| method on a dictionary that doesn't already have that key, Python will create the key and populate it with the data that you specify. You can then use this key as if you had created it by using the first method of appending to a dictionary.
\subsubsection*{Exercise Questions}
These exercise questions cover chapter 5.2
\begin{Exercise}
    \Question{What is a dictionary?}
    \Question{What are the differences between Python lists and dictionaries?}
    \Question{Lists store data in [?]-[?] pairs, whereas dictionaries store data in [?]-[?] pairs. (Fill in the blanks)}
    \Question{Suppose you wanted to store the names of all of the NHL teams. Would you use a list or a dictionary? Why?}
\end{Exercise}
\begin{Exercise}
    \Question{Consider a potential dictionary named \verb|falcons| that would hold team data from the Atlanta Falcons NFL team. What are some key names that this dictionary might have?}
    \Question{Consider a potential dictionary that would hold information on one of the dorms on your campus. What might you name the dictionary? What are some key names that this dictionary might have?}
\end{Exercise}
\begin{Exercise}
    \Question{Create a new dictionary inside of a variable named \verb|eagles|. Add four keys: \verb|code|, \verb|city|, \verb|wins|, and \verb|winrate|. Initialize all of the keys to a \indexterm{Nonetype}.}
    \Question{In the \verb|eagles| dictionary, change the \verb|code| value to a string \verb|PHI|.}
    \Question{In the \verb|eagles| dictionary, change the \verb|city| value to a string\\ \verb|Philadelphia|.}
    \Question{In the \verb|eagles| dictionary, change the \verb|wins| value to an integer \verb|4|.}
    \Question{The Eagles played 16 games, of which they won four, tied one, and lost eleven. Use Python to calculate the win percentage. Win percentage is calculated using the following formula: ($2 \times \text{wins} + \text{ties}) / (2 \times \text{total games played}) \times 100$. Put the value in the \verb|eagles| dictionary in the \verb|winrate| key as a float. Try to do this in a single line.}
\end{Exercise}

\section{Tuples}
\newterm[Tuples]{datatype!tuple} are most often used to pass data between different data structures, which we'll cover in Chapter 7. You may have heard of tuples in precalculus, calculus, linear algebra, or some other mathematics course, where the definition of a tuple is a sequence of $n$ elements, where $n$ is some non-negative integer. Tuples, by definition, are ordered (given that they are a sequence), and they must be finite.\par
For example, $(2, 3, 4, 5, 6)$ is a valid mathematical tuple. It has a $n=5$, which is greater than zero and is finite. The size of this tuple is immutable - this is a 5-tuple, and it will always be a 5-tuple.\par
\boxtext{Tuple Notation}{If you haven't worked with tuples before, $n$-tuple notation is used to give the size of the tuple. A 5-tuple means that the tuple has 5 elements in it.}
Tuples are very similar in Python. Like a mathematical tuple, a tuple must have a size greater than 0 and must be finite. Unlike mathematical tuples, tuples can have different datatypes in them. Like in a list, you can mix booleans, integers, floats, and strings in a single tuple. You can also refer to tuple elements by their index number using square brackets, just like in lists. However, you cannot make a tuple larger or smaller after you create its size. If you create a 3-tuple, your tuple size is limited to 3. Tuples are also immutable. Once you create a tuple, you cannot change its value.\par
Consider the following tuple.\par
\begin{lstlisting}[style=pippython]
leafygreens = ("Romaine Lettuce", "Iceberg Lettuce", "Arugula")
\end{lstlisting}
We could refer to the second element (iceberg lettuce) by its index number 1.
\warningtext{Indices start at zero}{Indices start at 0 in Python!}
\begin{lstlisting}[style=pippython]
print(leafygreens[1])
\end{lstlisting}
\begin{lstlisting}[style=none]
Iceberg Lettuce
\end{lstlisting}
However, we cannot redefine the second element to be Butterhead Lettuce.\par
\begin{lstlisting}[style=pippython]
# NOT CORRECT
leafygreens[1] = "Butterhead Lettuce"
\end{lstlisting}
If I want to change an element in the tuple, I need to reinitialize the entire tuple variable.\par
\begin{lstlisting}[style=pippython]
leafygreens = ("Romaine Lettuce", "Butterhead Lettuce", "Arugula")
print(leafygreens[1])
\end{lstlisting}
\begin{lstlisting}
Butterhead Lettuce
\end{lstlisting}
If we want to store data, it is almost always more practical to use a list or a dictionary. However, there are still some cases where we would want to use a tuple: when we are interacting with functions. When we want to call a function and pass specified arguments to that function, we should use a tuple, since a tuple is of a fixed length and is immutable. In this use case, we will almost never see the tuple placed into a variable, but rather given as a tuple literal. Because of their limited use case, you probably won't want to use a tuple unless you see it in library documentation for some module that you're using. We wanted to introduce the concept of tuples to you regardless, since they do exist.

\section{Sets}
\newterm[Sets]{datatype!set} are the simplest of the complex datatypes, so if you understand lists, dictionaries, and tuples, you already understand a set.\par
In mathematics, sets are simply a collection of elements. There are no orders, sequences, or indices. Sets also cannot contain duplicate entries. Any duplicate entries will be ignored, since in a set, all that matters is whether an element is present in the set or not. This means that the set ${2, 3, 4}$ and ${2, 3, 4, 3}$ are the same, since the values 2, 3, and 4 are in both sets. In mathematics, we write sets inside of curly braces: ${2, 3, 4, 5, 6}$.\par

\section{Subsetting}
Now that we have seen indices in Python, we can subset based on those indices. For example, consider this list.\par
\begin{lstlisting}[style=pippython]
names = ["Peter Sagan",
    "Caleb Ewan",
    "Mathieu Van Der Poel",
    "Chris Froome",
    "Mark Cavendish"]
\end{lstlisting}
We know that lists are indexed at 0, so if we wanted to get Mathieu Van Der Poel out of the list, we could refer to \verb|names[2]|.
\begin{lstlisting}[style=pippython]
print(names[2])
\end{lstlisting}
\begin{lstlisting}[style=none]
Mathieu Van Der Poel
\end{lstlisting}
What if we wanted to get the first two elements from the list? We could refer to the \verb|0|'th and \verb|1|'s element, sure. But, a better tool is something called \newterm[subsetting]{datatype!subset}. Subsetting allows us to get any number of elements from a vector of objects, including strings and lists.\footnote{They also work on non-native datatypes, like the Pandas dataframe and series or the NumPy array, which we'll cover in Chapter 10.}\par
The subsetting operator is a colon inside of square brackets. The colon is sort of like a "to" operator, meaning that we can refer to index numbers $i$ to $j$ as \verb|[i:j]|. Consider the \verb|names| list from before. If we wanted to refer to the first three names, we really want names 0 to 3 (not including 3), so we can refer to this as the following.
\begin{lstlisting}[style=pippython]
print(names[0:3])
\end{lstlisting}
\begin{lstlisting}[style=none]
['Peter Sagan', 'Caleb Ewan', 'Mathieu Van Der Poel']
\end{lstlisting}
If we wanted names 1 and 2, we could use this.
\begin{lstlisting}[style=pippython]
print(names[1:3])
\end{lstlisting}
\begin{lstlisting}[style=none]
['Caleb Ewan', 'Mathieu Van Der Poel']
\end{lstlisting}
What if we wanted to refer to the last element of the vector? Python supports something really cool called \newterm[negative indexing]{datatype!subset!negative indexing}. This essentially counts the vector in reverse order, starting at -1. So, the last element is -1, the second-to-last element is -2, the third-to-last element is -3, and so on. If we wanted to get the last element of the \verb|names| list, we could use negative indexing to get that element.
\begin{lstlisting}[style=pippython]
print(names[-1])
\end{lstlisting}
\begin{lstlisting}[style=none]
'Mark Cavendish'
\end{lstlisting}
If we wanted the second-to-last element, we could use negative indexing to get just that element.\par
\begin{lstlisting}[style=pippython]
print(names[-2])
\end{lstlisting}
\begin{lstlisting}[style=none]
'Chris Froome'
\end{lstlisting}
Subsetting also works on strings, where each character in the string is considered its own element. So, let's say we had the string:
\begin{lstlisting}[style=pippython]
text = "This will begin to make things right. I've traveled too far, and seen too much, to ignore the despair in the galaxy. Without the Jedi, there can be no balance in the Force. Well, because of you now we have a chance."
\end{lstlisting}
This isn't a \textit{short} string persay, and we might not want to print the whole string every time. If we want the first few characters of the string, we can use the third type of subsetting: \newterm[implicit subsetting]{datatype!subset!implicit}. Implicit subsetting is deliberately leaving out either the to or from marker. In implicit subsetting, Python will assume that you want to subset from the beginning of the vector to the set mark or from the set mark to the end of the vector. Where a blank exists, Python fills the blank with either the first element (if the "from" element is blank) or the last element (if the "to" element is blank). Consider the above string. If we only wanted to print the first 30 characters of this string, we can use implicit subsetting to tell Python that we want to print the beginning of the string up to the 30th element.\par
\begin{lstlisting}[style=pippython]
print(text[:30])
\end{lstlisting}
\begin{lstlisting}[style=none]
This will begin to make things
\end{lstlisting}
Similarly, if we wanted to print the all but the first 50 characters of this string, we can use implicit subsetting to tell Python that we want to print from the 50th element to the last element.
\begin{lstlisting}[style=pippython]
print(text[50:])
\end{lstlisting}
\begin{lstlisting}[style=none]
d too far, and seen too much, to ignore the despair in the galaxy. Without the Jedi, there can be no balance in the Force. Well, because of you now we have a chance.
\end{lstlisting}
We can also throw negative indexing into our implicit subsetting for an extra fun time! If we wanted to print only the last 50 characters, we could use negative indexing and an implicit subset. This is essentially telling Python to give us from the 50th-to-the-last element to the last element.
\begin{lstlisting}[style=pippython]
print(text[-50:])
\end{lstlisting}
\begin{lstlisting}[style=none]
 Force. Well, because of you now we have a chance.
\end{lstlisting}
Similarly, we could tell Python to give us from the first element to the 50th-to-the-last element.
\begin{lstlisting}[style=pippython]
print(text[:-50])
\end{lstlisting}
\begin{lstlisting}[style=none]
This will begin to make things right. I've traveled too far, and seen too much, to ignore the despair in the galaxy. Without the Jedi, there can be no balance in the
\end{lstlisting}
Negative indexing and implicit subsetting also work with lists. If we consider our \verb|names| list and we wanted from the third-to-the-last to the last element, we could use implicit subsetting with a negative index to get those three elements.
\begin{lstlisting}[style=pippython]
print(names[-3:])
\end{lstlisting}
\begin{lstlisting}[style=none]
['Mathieu Van Der Poel', 'Chris Froome', 'Mark Cavendish']
\end{lstlisting}

\section{String Manipulation}
We just covered subsetting, including in strings and in lists, but we will cover two more methods for manipulating strings in Python: stripping and matching.
\subsection{Stripping}
An important feature of string handling is the ability to remove characters from a string. For example, let's say you got some data and it was formatted as \verb|&&data&&| or it was surrounded by spaces. How could we get rid of this cruft?\par
The process of stripping removes unwanted characters from a string. Python provides us with three stripping methods: left stripping, right stripping, and dual stripping. As their names suggest, these methods can remove characters from the left side of the string, the right side of the string, or from both sides of the string at the same time, respectively. The functions to do this are \verb|lstrip()|, \verb|rstrip()|, and \verb|strip()|.\par
By default, all three methods only remove whitespace. So, if you had extra tabs or spaces at the beginning or end of your string, you could simply call the \verb|strip| method to remove the whitespaces.\par
\begin{lstlisting}[style=pippython]
print("  data  ")
print("  data  ".strip())
\end{lstlisting}
\begin{lstlisting}[style=none]
  data  
data
\end{lstlisting}
We didn't give the \verb|strip()| method anything, so it only removed the spaces. However, we could also give it letters, numbers, symbols, or any other valid characters. For example, consider the following two print statements.\par
\begin{lstlisting}[style=pippython]
print("fpppppppppppppppffdatapffffffppppp")
print("fpppppppppppppppffdatapffffffppppp".strip("fp"))
\end{lstlisting}
\begin{lstlisting}[style=none]
fpppppppppppppppffdatapffffffppppp
data
\end{lstlisting}
As soon as Python runs into a character that shouldn't be stripped, it stops evaluating from that side. So, even if my word contained \verb|p| and \verb|f|, it wouldn't get stripped out. For example, consider the following print statement.\par
\begin{lstlisting}[style=pippython]
print("pppppppppppppapplepppp".strip("p"))
\end{lstlisting}
\begin{lstlisting}[style=none]
apple
\end{lstlisting}
The word "apple" has the letter \verb|p| in it, but it doesn't get stripped out because Python has stopped when it reached the \verb|a|.\par
Let's now consider the left stripping. Left-stripping will remove letters that match stop words from the beginning of the string only.\par
\begin{lstlisting}[style=pippython]
print("pppppppppppppapplepppp".lstrip("p"))
\end{lstlisting}
\begin{lstlisting}[style=none]
applepppp
\end{lstlisting}
Python removed all of the \verb|p|'s on the left side, up to the first non-stripped character. It didn't remove anything from the right side, though. If we wanted to only remove the right-side characters, we can use the \verb|rstrip()| method.\par
\begin{lstlisting}[style=pippython]
print("pppppppppppppapplepppp".rstrip("p"))
\end{lstlisting}
\begin{lstlisting}[style=none]
pppppppppppppapple
\end{lstlisting}
\subsection{Regular Expression Matching}
What if we wanted to match a chunk of a string? This is where regular expressions come in. Regular expressions, or \newterm[regexes]{regex} allow us to match or check if a match exists between two strings. Regexes have some special style that allows us to match as specifically or as broadly as is necessary for the application.\par
\subsubsection{Regexes}
For this section, let's consider the following text.
\begin{lstlisting}[style=none]
He is headstrong and he has much to learn of the living Force, but he is capable. There is little more he can learn from me. Young Skywalker's fate will be decided later. Now is not the time for this. the Senate is voting for a new Supreme Chancellor and Queen Amidala is returning home, which will put pressure on the Federation, and could widen the confrontation. And draw out the Queen's attacker.
\end{lstlisting}
The most simple regex is a direct match. To make a direct match, we simply enter the string to match. Let's try to match the word "the". The regex parser will find 6 matches ("of the living," "not the time", "the Senate is," "on the Federation," "widen the confrontation," and "out the Queen's").\par
If we chose a direct match that occurs inside of other words, the regex parser will grab those as well. For example, if we try to match the phrase "ch", the regex parser will find 2 matches ("has much to" and "home, which will").\par
There are several characters that we can use to modify the regex search, with the most greedy being the period. This character is something called a \newterm[wildcard]{regex!wildcard}, which means that it can match different things that adhere to a certain condition. The period matches any single character, meaning that each character in our text has been matched ("H", "e", " ", "i", "s", " ", "h", "e", "a", "d", "s", "t", "r", "o", "n", "g", " "...).\par
What if we wanted to find a word character only? This is where the word wildcard comes in: \verb|\w|. The \verb|\w| wildcard matches any word character, including from A-Z, a-z, 0-9, or the underscore character. In our text, the \verb|\w| wildcard would match "H", "e", "i", "s",..., "e", "r", but skip spaces, periods, and apostrophes. Similarly, the \verb|\d| wildcard matches any digit from 0-9. It would find no matches in the text above, since the text above has no digits. The \verb|\s| wildcard matches any whitespace, including spaces, tabs, newlines, and carriage returns.\par
\warningtext{Case Sensitive}{Regexes are case sensitive, meaning that \texttt{\textbackslash d} and \texttt{\textbackslash D} are not the same thing.}
The \verb|\w|, \verb|\d|, and \verb|\s| wildcards also have negative versions, meaning that it will search the opposite. The negative versions are the capital \verb|\W|, \verb|\D|, and \verb|\S|, which will find \textit{non}-word, \textit{non}-digit, and \textit{non}-whitespace characters, respectively. That means that using the \verb|\s| (lowercase) wildcard catches all of the spaces and the newline at the end of the passage, while the \verb|\S| (uppercase) wildcard catches all of the letters, numbers, and symbols but no spaces or newlines.\par
We can also create our own custom character sets to select by. For example, if we wanted only the letters \verb|a|, \verb|b|, \verb|c|, \verb|d|, and \verb|e| to be captured, you can use a custom character set. To create a custom character set, just enclose the characters that you want to include in square brackets. So, to catch \verb|a|, \verb|b|, \verb|c|, \verb|d|, and \verb|e|, we would write \verb|[abcde]|. This would catch every letter that is a, b, c, d, or e, lowercase only. In our passage, it would catch the \verb|e| in \verb|He|, but not the \verb|H|. It also catches the \verb|e|, \verb|a|, and \verb|d| in \verb|headstrong|. If we wanted to include capitals, we would need to explicitly set this in our regex: \verb|[ABCDEabcde]|. This would also catch the \verb|C| in \verb|Chancellor|.\par
Regexes also can span a range of letters by using the dash \verb|-|. For example, if we wanted to rewrite the previous regex (\verb|[ABCDEabcde]|) using a dash, we could write \verb|[A-Ea-e]|. This works for \verb|[A-Z]|, \verb|[a-z]|, and \verb|[0-9]|. So, the following regex would capture every letter and number from A-z, 0-9, no matter the case: \verb|[A-Za-z0-9]|.\par
To this point, we have only been covering single characters unless we specify a literal match. What if we want to match multiple letters? This is called a quantifier, and it allows us to match multiples of characters together as one. For example, if we wanted to match an entire word (instead of matching letters of a word), we would use a quantifier on a letter wildcard. There are six valid quantifiers.
\begin{itemize}
\item \verb|?| matches zero or one of the previous token
\item \verb|*| matches zero or more of the previous token
\item \verb|+| matches one or more of the previous token
\item \verb|{n}| matches exactly $n$ of the previous token
\item \verb|{n,}| matches $n$ or more of the previous token
\item \verb|{n,m}| matches between $n$ and $m$ of the previous token
\end{itemize}
Let's apply this to our passage. We'll use the \verb|[A-Za-z]| regex as our token to quantify. If we apply the \verb|?| quantifier, our regex looks like \verb|[A-Za-z]?|, and this will match every single letter, as well as a \verb|None| at the end of every word, since the end of every word has zero of the \verb|[A-Za-z]| token.\par 
If we use the \verb|*| quantifier, our regex looks like \verb|[A-Za-z]*|, and this will match zero or one capital or lowercase letters. This will match every single word, but it will also match the end of every word, resulting in every other match being \verb|None| or \verb|null|.\par
Instead, we might want to use the \verb|+| quantifier, which will look like \verb|[A-Za-z]+|. This will match entire words separated by anything that isn't a letter. We don't get any \verb|None|s or nulls.\par
If we use the \verb|{2}| quantifier, our regex will look like \verb|[A-Za-z]{2}|. This will match all two letter pairs. So, it will match \verb|He| and \verb|is|, but it will also match the chunks of "headstrong" as \verb|he|, \verb|ea|, \verb|ds|, \verb|ro|, and \verb|ng|.\par
If we use the \verb|{3,}| quantifier, our regex will look like \verb|[A-Za-z]{3,}|. This will match all words that are three letters long or longer. So, it won't match \verb|He| or \verb|is|, but it will match \verb|headstrong| and \verb|and|.\par
If we use the \verb|{3,6}| quantifier, our regex will look like \verb|[A-Za-z]{3,6}|. This will match all words that are three letters long or longer, but six letters long or shorter. So, this will match \verb|and| and \verb|much|, but it won't match with the entirety of "headstrong". However, it will match \verb|headst| and \verb|rong| from \verb|headstrong|.\par
If we wanted to match only entire words, we need to use something called a word boundary. Word boundaries limit matches to immediately between a character matched by the \verb|\w| (lowercase) wildcard and a character by \verb|\W| (capital) wildcard (in either order). So, if we wanted to only find whole words that are between 3 and 6 letters long that are lowercase or have uppercase letters, we would have to put word boundaries around the beginning and end to make sure that the space is present at the beginning and end of the word. This would look like \verb|\b[A-Za-z]{3,6}\b|. This regex would match word like \verb|and| and \verb|Senate|, but it would not match \verb|headstrong|, since by the sixth character, the next character is not a \verb|\W| character.\par
This is a very basic introduction to regexes. Regexes can become incredibly complex. For example, something as simple as an email address can require a doozy of a regex.\par
\begin{lstlisting}[style=none]
(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?|\[(?:(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9]))\.){3}(?:(2(5[0-5]|[0-4][0-9])|1[0-9][0-9]|[1-9]?[0-9])|[a-z0-9-]*[a-z0-9]:(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])
\end{lstlisting}
This regex is actually on the shorter end of email-address-validating regexes. However, the best way to get started with regexes is to write them out.
\subsubsection{Regex Matching in Python}
Python has a library called \verb|re| that provides regular expression matching capabilities. This library can be loaded by this line.\par
\begin{lstlisting}[style=pippython]
import re
\end{lstlisting}
One of the most common methods inside of \verb|re| is the \verb|match()| method. The \verb|match()| method takes two arguments: \verb|pattern| and \verb|string|, which correspond to the regex and the string to be tested. The \verb|match()| method, as its name suggests, matches at the beginning of the string.\par
In Python, when we write out a regex, we should specify to Python that we are actually writing out a regex instead of just a regular string, and we do that by fixing a \verb|r| to the beginning of the string, before the opening quotation mark.\par
Let us consider the following string.\par
\begin{lstlisting}[style=pippython]
teststr = "Traveling through hyperspace isn't like dusting crops, boy! Without precise calculations we could fly right through a star or bounce too close to a supernova and that'd end your trip real quick, wouldn't it? What's that flashing? We're losing our deflector shield. Go strap yourself in, I'm going to make the jump to light speed. We've entered the Alderaan system. Governor Tarkin, I should have expected to find you holding Vader's leash."
\end{lstlisting}
Let's say that we wanted to find all of the full words that were longer than 4 letters. Our regex for this would look like \verb|\b[A-Za-z]{4,}\b|. This regex matches the letters from A-Z and a-z (case insensitive) in sequences of at least four letters long between two word boundaries. We can apply this to the \verb|match()| method as follows.\par
\begin{lstlisting}[style=pippython]
matches = re.match(r'\b[A-Za-z]{4,}\b', teststr)
\end{lstlisting}
Notice how the regex is prefixed with a \verb|r|. This tells Python that this should be treated as a regex, and normal escaping should be ignored.\cprotect\footnote{If normal escaping is in effect, things like \verb|\n| would be evaluated as newlines instead of as a newline in a regex, and your regex would likely not work correctly.}\par
The \verb|match()| method returns a \verb|Match| object with the first valid match. We can get the match by looking at the \verb|0|th element of the \verb|Match| object, which returns the entire match.
\begin{lstlisting}[style=pippython]
print(matches[0])
\end{lstlisting}
\begin{lstlisting}[style=none]
Traveling
\end{lstlisting}
In this case, the first match is the word \verb|Traveling|. There is no object at \verb|[1]|, since the \verb|match()| method only returns the first match. But what if we wanted to get all of the matches?\par
This is where the \verb|findall()| method comes in. The \verb|findall()| method scans through the entire string and puts the resulting matches into a list. Here is the same regex, but using the \verb|findall()| method instead of the \verb|match()| method. Again, this regex matches the letters from A-Z and a-z (case insensitive) in sequences of at least four letters long between two word boundaries.
\begin{lstlisting}[style=pippython]
matches = re.findall(r'\b[A-Za-z]{4,}\b', teststr)
print(matches)
\end{lstlisting}
\begin{lstlisting}[style=none]
['Traveling', 'through', 'hyperspace', 'like', 'dusting', 'crops', 'Without', 'precise', 'calculations', 'could', 'right', 'through', 'star', 'bounce', 'close', 'supernova', 'that', 'your', 'trip', 'real', 'quick', 'wouldn', 'What', 'that', 'flashing', 'losing', 'deflector', 'shield', 'strap', 'yourself', 'going', 'make', 'jump', 'light', 'speed', 'entered', 'Alderaan', 'system', 'Governor', 'Tarkin', 'should', 'have', 'expected', 'find', 'holding', 'Vader', 'leash']
\end{lstlisting}
Now, let's suppose that we had a comma-separated file and we wanted to separate the individual elements into a list, without the commas. This is where we would use the \verb|split()| method. The \verb|split()| method splits a string at every match and puts everything between the matches into list elements.\par
Let's suppose that we had the following string, which represents comma-separated values.
\begin{lstlisting}[style=pippython]
testcommas = "172,Austin Czarnik,czarnau01,29,Eastern,Metropolitan,NYI,Off,C,12,95,86,52.5,5.4,72,61,54.1,7.1,16.9,91.8,108.8,51.7,48.3,11:02,10:22,4,4,-0.1,16,62.5,0:41,10:23,3.5,4.2,1.6,0:27,7.7,14,0,0:11,-11,0,23.7,2,4,6,6,0,0.9,2,0,0,0,4,0,0,10,20,132,11:02,5,2,23,35,39.7"
\end{lstlisting}
If we call the \verb|split()| method to split on commas, we will split this string into individual cells without the commas. For this, we will use the regex \verb|r','|, which matches on the literal comma character \verb|,|.\par
\begin{lstlisting}[style=pippython]
matches = re.split(r",", testcommas)
print(matches)
\end{lstlisting}
\begin{lstlisting}[style=none]
['172', 'Austin Czarnik', 'czarnau01', '29', 'Eastern', 'Metropolitan', 'NYI', 'Off', 'C', '12', '95', '86', '52.5', '5.4', '72', '61', '54.1', '7.1', '16.9', '91.8', '108.8', '51.7', '48.3', '11:02', '10:22', '4', '4', '-0.1', '16', '62.5', '0:41', '10:23', '3.5', '4.2', '1.6', '0:27', '7.7', '14', '0', '0:11', '-11', '0', '23.7', '2', '4', '6', '6', '0', '0.9', '2', '0', '0', '0', '4', '0', '0', '10', '20', '132', '11:02', '5', '2', '23', '35', '39.7']
\end{lstlisting}

\section{Random Number Generation}
Now that we have knowledge of complex datatypes, it makes sense for us to now cover random number generation, since some random number generation outputs rely on prior knowledge of complex datatypes.\par
Random number generation is a very useful feature of any programming language, but in order to understand the limitations of random number generation, we need to understand why computers can't generate random numbers.\par
If you've used a Texas Instruments TI-84 graphing calculator, you may have generated random numbers using it. If you were in a classroom with others, you might've gotten the same random numbers, meaning that the numbers aren't really randomly generated.\par
This is a deficiency with computers. Computers are inherently unable to generate random numbers due to their procedural nature. Because of this, computers have to use pseudo-random number generation techniques.\par
\funtext{RNG in the real world}{Video games use random numbers to carry out many of their functions, and sometimes, certain random numbers may make the game much more difficult. If you hear the phrase "bad RNG," now you know what that means!}
Random number generation in a computer starts with something called a seed. In a computer, random numbers are generated as the result of a mathematical function, and the seed is the input to that mathematical function that will return a pseudo-random number. Sometimes, seeding by hand is a good thing, because it will ensure that we will get the same "random" number every single time. This is great for testing purposes.\par
However, seeding can also be done by something completely unrelated to the computer. Some programs seed according to insanely small units of time, like nanoseconds. Others seed using arbitrary numeric data, like processor cycles. Yet others seed using external data.\par
\funtext{Lava lamps}{Cloudflare's San Francisco office famously seeds its cryptographic functions using a camera feed of lava lamps. The lava lamps move in random ways, and the camera used to capture the lava lamps has digital noise that cannot be predicted.}
After a seed has been chosen, it needs to be processed. Modern random-number generators are good enough that you can treat the near-randomness of your random number as random. However, older random-number generators were much more primative. One of these methods is called linear congruential generation, or LCG. LCG uses a mathematical function, iterated over multiple times, to create a random number.\par
To use LCG, you need to have four things: a minimum, a maximum, a seed, and the number of iterations.\par
The generator itself is quite a simple machine. Using itself, it creates mathematically related output based off of its own output. The LCG equation is given as

$$
x = (a * x + c) \text{ mod }m
$$

where $a$ is the multiplier, $c$ is the increment amount for each iteration, and $m$ is a modulus, which are all constant values. $x$ is the seed. Every time a new number is needed, the increment amount increases the mutiplier by $c$. Then, to get the number in the right range, we can use

$$
o = \frac{(r_\text{upper} - r_\text{lower}) * ((a * x + c) \text{ mod }m)}{(m - 1) + r_\text{lower}}
$$

to get a number, where $r_\text{upper}$ is the upper range of our possible random numbers, $r_\text{lower}$ is the lower range of our possible random numbers, and $o$ is the random number.\par
This is a very primative pseudo-random number generator. There are only as many intermediate steps from the seed to the pseudo-random number as iterations, and in general, more intermediate steps leads to better random numbers. Because of this, LCGs are rarely used anymore, but their theory of operation make them a useful tool for understanding why we get the random numbers that we do.\par
Thankfully, Python has a simple library that allows us to use a much more sophisticated pseudo-random number generator. Predicably, this library is called \verb|random|. There are three methods inside of \verb|random| that will be of great use to us: \verb|random()|, \verb|randint()|, and \verb|choice()|.\par
Let us start with \verb|random()|. The \verb|random()| method generates pseudo-random floating-point values on a uniform real distribution from 0 to 1. As opposed to the very simple linear congruential generator that we previously used, \verb|random()| uses the Mersenne Twister generator, which is a much more complex and precise generator than the LCG.\par
\funtext{Mersenne Twisters in C}{Python is built on top of C, and it actually uses the C-based Mersenne Twister generator found in \texttt{mt19937} for 32-bit C and \texttt{mt19937\_64} for 64-bit C. It produces a 53-bit precision float and uses a modulus of 2 mod 19937 - 1 (hence C's generator naming).}
To use the \verb|random()| method in Python, we first need to import the \verb|random| library.\par
\begin{lstlisting}[style=pippython]
import random
\end{lstlisting}
Now, we can call the \verb|random()| method to generate a random floating-point number from 0 to 1.\par
\begin{lstlisting}[style=pippython]
print(random.random())
print(random.random())
print(random.random())
\end{lstlisting}
\begin{lstlisting}[style=none]
0.7592076143986661
0.22557165065717144
0.01434871426522899
\end{lstlisting}
More often than not, we will want to generate a random integer. We could use the \verb|random()| method and pull a little bit from the output, but that's a lot of work. So instead, let's use the \verb|randint()| method. The \verb|randint()| method takes two arguments, a minimum and a maximum for the random number.\par
\begin{lstlisting}[style=pippython]
print(random.randint(1, 10))
print(random.randint(1, 10))
print(random.randint(1, 10))
\end{lstlisting}
\begin{lstlisting}[style=none]
3
2
7
\end{lstlisting}
Now, let's suppose that we have a list with two coin sides: heads and tails.\par
\begin{lstlisting}[style=pippython]
coin = ['heads', 'tails']
\end{lstlisting}
If we wanted to generate a coin flip, we could generate a random integer, then get the value of the item at that index list.\par
\begin{lstlisting}[style=pippython]
print(coin[random.randint(0, 1)])
\end{lstlisting}
\begin{lstlisting}[style=none]
heads
\end{lstlisting}
However, since we have a list already, this is the perfect scenario to use the \verb|choice()| method, which picks a pseudo-random choice from a list.\par
\begin{lstlisting}[style=pippython]
print(random.choice(coin))
\end{lstlisting}
\begin{lstlisting}[style=none]
heads
\end{lstlisting}
We mentioned seeds when we were talking about linear congruential generators, and it's not for nought. Every random number generator has a seed. Whether you can see or edit that seed or not doesn't matter - the seed \textit{is} there. Again, it could be seeded from something else (like a video feed of a lava lamp). By default, Python seeds its random numbers from the current system time. Hoewver, Python's \verb|random| library allows us to set a seed manually so that our results can be reproducable. That means that if I set my seed to be \verb|215|, then I generate a random integer, it should be the same as if you set your seed to be \verb|215|, then generated a random integer.\par
In Python, the \verb|random| class has a method that we can use to set a seed manually called \verb|seed()|. Once we set the seed, it is the same for the rest of the environment.\par
\begin{lstlisting}[style=pippython]
random.seed(215)
print(random.randint(1, 100))
\end{lstlisting}
\begin{lstlisting}[style=none]
6
\end{lstlisting}
If your seed was set to the 215, the first random integer that you generate from 1 to 100 should be 6.